---
layout: post
title: 02多线程共享对象
category: 技术
tags: Java基础
keywords: java并发编程 对象的共享
description:
---

　　本篇主要讲，如何发布一个对象，使它可以安全的被多个线程访问。在上一篇我们知道用synchronized加锁机制可以构建的同步代码块，实现原子性操作，其实同步还有另一个重要的方面———内存可见性，即当同步的内容被某一个线程修改了以后，其它的线程能够看到内容的变化。

###1、内存的可见性
　　synchronized同步代码块有两方面的作用，原子性操作和内存的可见性。加锁的含义不仅仅局限于互斥行为，还包括内存的可见性，为了保证所有的线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在一个锁上同步。

###2、volatile变量

　　volatile变量，用来确保将变量的更新通知到其它线程。读取volatile类型的变量时，总会返回最新被写入的值。volatile变量常用于检查某个状态标记，以确认是否退出循环。

>加锁机制（synchronized）既可以保证内存可见性又可以保证原子性，volatile变量只能保证内存的可见性。

###3、线程封闭

　　如果在单线程内访问数据就不需要同步，将某个对象封闭在一个线程中，这是实现线程安全的最简单的方式之一。

>线程封闭的典型例子是应用服务器提供的连接池，每一个Connection同时只能被一个线程获取，当该线程用完后将Connection还给连接池，下一个线程才可以用。

　　java提供了局部变量和ThreadLocal类来实现线程封闭。

* 局部变量

　　局部变量的固有属性之一就是封闭在执行的线程中，他们的状态保存在执行线程的栈内存中，其它线程无法访问。

* ThreadLocal类

　为每一个线程都提供一个访问变量的副本，就像每个线程都拥有该变量，互不影响。

>常用于防止对可变的单实例变量进行共享（通过线程单例防止），以及防止对全局变量进行共享。


###不变性

　　Final类型的域是不能修改的，不可变对象一定是线程安全的。

>除非需要某个域是可变的，否则将其声明为final域是一个很好的编程习惯。
